{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the NGFF Workshop!","text":"<p>This workshop covers all the key steps for working with OME-Zarr datasets, including converting, inspecting, validating, opening, saving, and visualizing OME-Zarr data. Below are the sections for easy navigation.</p>"},{"location":"#overview","title":"Overview","text":"<p>The objective of this workshop is to guide you through working with OME-Zarr datasets using a variety of tools and techniques.  Each section of this tutorial is designed to cover a key part of working with OME-Zarr,  and we encourage you to explore each one in detail.</p>"},{"location":"#converting-data-to-ome-zarr","title":"Converting Data to OME-Zarr","text":""},{"location":"#inspecting-and-validating-ome-zarr","title":"Inspecting and Validating OME-Zarr","text":""},{"location":"#opening-ome-zarr","title":"Opening OME-Zarr","text":""},{"location":"#saving-ome-zarr","title":"Saving OME-Zarr","text":""},{"location":"conversion_overview/","title":"Overview","text":"<p>Convert monolithic file formats to OME-Zarr.</p>"},{"location":"conversion_overview/#preparation","title":"Preparation","text":"<p>Download and extract the test_data to a local directory such as: <code>~/ngff_workshop/data/tiff/tiff_series</code></p>"},{"location":"conversion_overview/#modules","title":"Modules","text":"<ul> <li>EuBI-Bridge</li> <li>NGFF Converter</li> <li>BatchConvert</li> </ul>"},{"location":"inspection_overview/","title":"Overview","text":"<p>Inspect and validate OME-Zarr datasets</p>"},{"location":"inspection_overview/#modules","title":"Modules","text":"<ul> <li>OME-Zarr Validator</li> <li>ome-zarr-py</li> <li>minio-client</li> </ul>"},{"location":"ome_zarr_creation_BatchConvert/","title":"BatchConvert","text":""},{"location":"ome_zarr_creation_BatchConvert/#perform-parallelised-conversion-of-image-data-collections-to-ome-zarr-using-batchconvert","title":"Perform parallelised conversion of image data collections to OME-Zarr using BatchConvert","text":"<p>Important note: BatchConvert is currently only supported on unix-based systems</p> <p>As input, use the <code>tiff_series</code> dataset.</p> <p>Perform parallelised, independent conversion: <pre><code>batchconvert omezarr \\\n/path/to/tiff_series \\\n/path/to/output_dir \n</code></pre> This command maps each input file in the <code>tiff_series</code> folder to a single OME-Zarr,  which is then transferred to the <code>output_dir</code> folder.</p> <p>Check the content of the <code>output_dir</code> folder: <pre><code>ls /path/to/output_dir\n</code></pre> Optional: Inspect the created OME-Zarr. </p> <p>Perform grouped conversion:</p> <p><pre><code>batchconvert omezarr \\\n--merge_files \\\n/path/to/tiff_series \\\n/path/to/concatenated_output_dir\n</code></pre> This conversion mode assumes that the input files are part of the same image and thus will merge them along a specific axis during the conversion process. The <code>--merge_files</code> flag specifies the grouped conversion option.</p> <p>Check the content of the <code>output_dir</code> folder: <pre><code>ls /path/to/concatenated_output_dir\n</code></pre> Optional: Inspect the created OME-Zarr. </p> <p>Perform grouped conversion with specific chunking, downscaling and compression parameters:</p> <p><pre><code>batchconvert omezarr \\\n--merge_files \\\n--compression_zarr zlib \\\n-ms 32 \\\n-cx 32 \\\n-cy 32 \\\n-cz 6 \\\n/path/to/tiff_series \\\n/path/to/concatenated_rechunked_output_dir\n</code></pre> Here we do not only concatenate images, but we create a resolution pyramid and specify chunk sizes in x, y and z dimensions.</p> <p>Check the content of the <code>zarr_series_concatenated_rechunked</code> folder: <pre><code>ls /path/to/concatenated_rechunked_output_dir\n</code></pre> Optional: Inspect the created OME-Zarr. Compare it to the one created earlier.</p>"},{"location":"ome_zarr_creation_EuBI-Bridge/","title":"EuBI-Bridge","text":""},{"location":"ome_zarr_creation_EuBI-Bridge/#perform-parallelised-conversion-of-image-data-collections-to-ome-zarr-using-batchconvert","title":"Perform parallelised conversion of image data collections to OME-Zarr using BatchConvert","text":"<p>Important note: BatchConvert is currently only supported on unix-based systems</p> <p>As input, use the <code>tiff_series</code> dataset.</p> <p>Perform parallelised, independent conversion: <pre><code>batchconvert omezarr \\\n/path/to/tiff_series \\\n/path/to/output_dir \n</code></pre> This command maps each input file in the <code>tiff_series</code> folder to a single OME-Zarr,  which is then transferred to the <code>output_dir</code> folder.</p> <p>Check the content of the <code>output_dir</code> folder: <pre><code>ls /path/to/output_dir\n</code></pre> Optional: Inspect the created OME-Zarr. </p> <p>Perform grouped conversion:</p> <p><pre><code>batchconvert omezarr \\\n--merge_files \\\n/path/to/tiff_series \\\n/path/to/concatenated_output_dir\n</code></pre> This conversion mode assumes that the input files are part of the same image and thus will merge them along a specific axis during the conversion process. The <code>--merge_files</code> flag specifies the grouped conversion option.</p> <p>Check the content of the <code>output_dir</code> folder: <pre><code>ls /path/to/concatenated_output_dir\n</code></pre> Optional: Inspect the created OME-Zarr. </p> <p>Perform grouped conversion with specific chunking, downscaling and compression parameters:</p> <p><pre><code>batchconvert omezarr \\\n--merge_files \\\n--compression_zarr zlib \\\n-ms 32 \\\n-cx 32 \\\n-cy 32 \\\n-cz 6 \\\n/path/to/tiff_series \\\n/path/to/concatenated_rechunked_output_dir\n</code></pre> Here we do not only concatenate images, but we create a resolution pyramid and specify chunk sizes in x, y and z dimensions.</p> <p>Check the content of the <code>zarr_series_concatenated_rechunked</code> folder: <pre><code>ls /path/to/concatenated_rechunked_output_dir\n</code></pre> Optional: Inspect the created OME-Zarr. Compare it to the one created earlier.</p>"},{"location":"ome_zarr_inspection_ome-zarr-py/","title":"ome-zarr-py","text":"<p>Use the ome_zarr tool for the inspecting and downloading OME-Zarrs from s3:</p> <p>Remote OME-Zarr data stored in a public s3 bucket can be inspected and downloaded using  the <code>ome-zarr-py</code> tool. </p> <p>Inspect 3 different remote datasets:</p> <pre><code>ome_zarr info https://uk1s3.embassy.ebi.ac.uk/EuBI/anna_steyer0/20160112_C.elegans_std_fullhead.zarr\n</code></pre> <pre><code>ome_zarr info https://uk1s3.embassy.ebi.ac.uk/idr/zarr/v0.4/idr0062A/6001240.zarr\n</code></pre> <pre><code>ome_zarr info https://s3.embl.de/i2k-2020/platy-raw.ome.zarr\n</code></pre> <p>Optional: Download the dataset <code>6001240.zarr</code> from s3 to a local path:</p> <pre><code># cd ~/image_data_formats/day1/ome_zarr\ncd /path/to/local/zarr # where you want to keep the data on your system\nome_zarr download https://uk1s3.embassy.ebi.ac.uk/idr/zarr/v0.4/idr0062A/6001240.zarr\n</code></pre> <p>Optional: Inspect the local dataset in the same way: <pre><code>ome_zarr info /path/to/local/zarr/6001240.zarr\n</code></pre></p>"},{"location":"ome_zarr_open_java_mobie/","title":"Mobie","text":"<ul> <li>Open Fiji with MoBIE</li> <li>[ Plugins &gt; MoBIE &gt; Open &gt; Open OME ZARR... ]<ul> <li><code>Image URI</code>: <code>https://s3.embl.de/i2k-2020/platy-raw.ome.zarr</code></li> <li><code>( Labels URI )</code>: <code>https://s3.embl.de/i2k-2020/platy-raw.ome.zarr/labels/cells</code></li> <li><code>( Labels Table URI )</code>: TODO</li> </ul> </li> </ul>"},{"location":"ome_zarr_open_java_n5-ij/","title":"n5-ij","text":""},{"location":"ome_zarr_open_java_n5-ij/#open-a-remote-ome-zarr-in-fiji","title":"Open a remote OME-Zarr in FijiOpen a subset of a remote OME-Zarr in Fiji","text":"<ul> <li>Open the n5-ij in Fiji via: </li> <li> <p><code>[ File &gt; Import &gt; HDF5/N5/Zarr/OME-NGFF ... ]</code></p> </li> <li> <p>In the window that opens, paste the following path in the uri space:</p> </li> <li> <p><code>https://s3.embl.de/ome-zarr-course/data/commons/xyz_8bit_calibrated__fib_sem_crop.ome.zarr</code></p> </li> <li> <p>Then click <code>Detect datasets</code> button as shown below:  </p> </li> <li> <p>The tool will display a multiscales schema with two datasets in the dialog box. Select one of the datasets as shown below and click OK: </p> </li> <li> <p>This will open the dataset in Fiji as a normal Fiji image (see below). </p> </li> </ul> <ul> <li> <p>Follow the same steps above do select a dataset but instead of directly opening the dataset, click the crop button in the window before clicking OK as shown below:  </p> </li> <li> <p>In the window that open, select the indices of the subset as shown below:  </p> </li> <li> <p>When you click OK, the specified subset of the image will be opened as shown below:  </p> </li> </ul>"},{"location":"ome_zarr_open_java_n5-viewer/","title":"n5-viewer","text":""},{"location":"ome_zarr_open_java_n5-viewer/#open-a-remote-ome-zarr-in-bigdataviewer","title":"Open a remote OME-Zarr in BigDataViewer","text":"<p>Now let's imagine the dataset you want to open is too large to fit the RAM of your machine. </p> <ul> <li>Open the n5-viewer in Fiji via: </li> <li> <p><code>[ Plugins &gt; BigDataViewer &gt; HDF5/N5/Zarr/OME-NGFF Viewer ]</code></p> </li> <li> <p>In the window that opens, paste the following path in the uri space: </p> </li> <li> <p><code>https://s3.embl.de/i2k-2020/platy-raw.ome.zarr</code> </p> </li> <li> <p>Then click <code>Detect datasets</code> button as shown below:  </p> </li> <li> <p>The tool will display a multiscales schema with 9 datasets in the dialog box. In this case, one can either open the individual datasets or the entire pyramid.  To do the latter, click on the multiscale object and then click OK as shown below:  </p> </li> <li> <p>This will open the multiscales object in BDV as shown below:  </p> </li> <li> <p>This is a huge (terabyte-scale) image, which is not amenable to processing as a whole in Fiji. It is possible, however, to extract subsets of it to Fiji and continue with processing. To do so, follow the steps below:</p> </li> <li> <p>In the BDV window, open the cropping window via:  <code>[ Tools &gt; Extract to ImageJ ]</code> (also see below)</p> </li> </ul> <p></p> <ul> <li>In the cropping window that opens, select the indices of the subset as shown below:   Note that this step may require incremental rotation of the image and adjustment of the bounding box until the desired region of interest is obtained. It is also important to check the size of the cropped volume  at the top of the cropping window to make sure that it is not larger than the memory. Once you are fine with the settings, click OK. </li> <li>The output is a standard Fiji image as shown below:  </li> </ul> <p>Note that this image has been loaded into the RAM; as such, it can be processed like any other  Fiji image and saved to any desired file format. </p>"},{"location":"ome_zarr_visualisation_napari/","title":"napari-ome-zarr","text":""},{"location":"ome_zarr_visualisation_napari/#visualise-the-remote-data-using-napari-together-with-the-napari-ome-zarr-plugin","title":"Visualise the remote data using Napari together with the napari-ome-zarr plugin.","text":"<p>Use command line: <pre><code>napari --plugin napari-ome-zarr https://uk1s3.embassy.ebi.ac.uk/idr/zarr/v0.4/idr0062A/6001240.zarr\n</code></pre></p> <p>Use Python code:</p> <p>Approach 1: Open the full OME-Zarr from the top level url: <pre><code>import napari\n\nv = napari.Viewer()\nv.open(\"https://uk1s3.embassy.ebi.ac.uk/idr/zarr/v0.4/idr0062A/6001240.zarr\",\n       plugin = 'napari-ome-zarr'\n       )\nnapari.run()\n</code></pre> Note that this approach automates a lot of tasks for the user, discovering look-up tables, pixel scalings and units from the OME-Zarr metadata.</p> <p>Approach 2: Read arrays and open them individually: <pre><code>import napari\nimport zarr, dask.array as da\n\nurl = \"https://uk1s3.embassy.ebi.ac.uk/idr/zarr/v0.4/idr0062A/6001240.zarr\"\ngr = zarr.open_group(url, mode = 'r')\n#array0 = da.from_zarr(gr[0])\narray2 = da.from_zarr(gr[2])\n#label_array0 = da.from_zarr(gr.labels['0'][0])\nlabel_array2 = da.from_zarr(gr.labels['0'][2])\nv = napari.Viewer()\n#v.add_image(array0, contrast_limits = (0, 2000), colormap = 'yellow')\nv.add_image(array2, contrast_limits = (0, 2000), colormap = 'red')\n#v.add_labels(label_array0)\nv.add_labels(label_array2)\nnapari.run()\n</code></pre></p> <p>Note that approach 2 is flexible but does not use any metadata. You have to specify the metadata to the viewer manually.</p>"},{"location":"ome_zarr_visualisation_s3_bia/","title":"S3 Visualization (BIA)","text":"<p>https://uk1s3.embassy.ebi.ac.uk/bia-integrator-data/pages/S-BSST410/IM2.html</p>"},{"location":"ome_zarr_visualisation_s3_itk_viewer/","title":"ITK Viewer","text":"<p>https://kitware.github.io/itk-vtk-viewer/app/?fileToLoad=https://uk1s3.embassy.ebi.ac.uk/bia-integrator-data/S-BSST410/IM2/IM2.zarr/0</p>"},{"location":"ome_zarr_visualisation_s3_mobie/","title":"Mobie for s3","text":"<ul> <li>Run Fiji with MoBIE</li> <li>Open OME-Zar with labels and label table in MoBIE:</li> <li><code>[ Plugins \u203a MoBIE \u203a Open \u203a Open OME ZARR... ]</code><ul> <li>Image URI: <code>https://s3.embl.de/i2k-2020/platy-raw.ome.zarr</code> (8 TB)</li> <li>Labels URI: <code>https://s3.embl.de/i2k-2020/platy-raw.ome.zarr/labels/cells</code> </li> <li>Labels Table URI: <code>https://raw.githubusercontent.com/mobie/platybrowser-project/refs/heads/main/data/1.0.1/tables/sbem-6dpf-1-whole-segmented-cells/default.tsv</code></li> <li>Note that the labels table is not integrated within the OME-Zarr, because a specification for this does not, despite hard work, yet exist. MoBIE supports a number of table formats and column names (see here).</li> </ul> </li> </ul>"},{"location":"ome_zarr_visualisation_s3_neuroglancer/","title":"Neuroglancer","text":"<ul> <li>Open an image:</li> <li>Go to https://neuroglancer-demo.appspot.com/</li> <li>On to top right in <code>Source</code>, enter, e.g., <code>zarr://https://s3.embl.de/i2k-2020/platy-raw.ome.zarr</code> (replace the part behind <code>zarr://</code> with your URL. </li> <li>Press Enter (multiple times).</li> <li>Navigate around in the sample</li> <li>Zooming seems to require pinching on a trackpad</li> <li>Sharing views:</li> <li>The URL in your browser adapts to your current view</li> <li>Copy and paste the URL to share a view with a collaborator</li> <li>For example, try this one</li> </ul>"},{"location":"ome_zarr_visualisation_s3_vizarr/","title":"Vizarr","text":"<p>https://hms-dbmi.github.io/vizarr/?source=https://uk1s3.embassy.ebi.ac.uk/bia-integrator-data/S-BSST410/IM2/IM2.zarr</p>"},{"location":"ome_zarr_visualisation_s3_webknossos/","title":"Webknossos","text":"<p>https://webknossos.org/datasets/platy-i2k-2020-633e802f010000d3007f8f32/view?utm_source=wklink#15331,15581,6482,0,61.339</p> <p>Note that this loads data from <code>https://s3.embl.de/i2k-2020/platy-raw.ome.zarr</code></p>"},{"location":"omet_zarr_conversion_ngff-converter/","title":"NGFF-Converter","text":"<ul> <li>Download example image Leica LIF image:</li> <li>Open the NGFF converter; tool website <ul> <li>Drag and drop the image file</li> <li>A dialog will open:<ul> <li>Output format: OME-NGFF</li> <li>Output location: Choose some folder on your computer</li> <li>[ Apply ]</li> </ul> </li> <li>[ Run Jobs ]</li> </ul> </li> <li>Inspect the OME-NGFF output using your file browser</li> <li>Inspect the XML in the OME subfolder using your web browser</li> <li>Open the OME-NGFF images using a tool of your choice, e.g. Fiji N5</li> </ul>"},{"location":"open_local_ome_zarr_zarr-python/","title":"zarr-python","text":"<p>Import the necessary tools: <pre><code>import zarr, os, pprint\nimport numpy as np\n</code></pre></p> <p>Open the local OME-Zarr using <code>zarr.open_group</code> <pre><code>#path = f\"{os.path.expanduser('~')}/image_data_course/data/zarr/6001240.zarr\"\npath = \"/path/to/local/zarr\"\ndataset = zarr.open_group(path, mode = 'r')\nprint(f\"Type of the dataset: {type(dataset)}\")\n</code></pre></p> <p>Summarize group-level metadata: <pre><code>dataset.info\n</code></pre> Note the store type, the number of arrays and groups. \\ Note also the group named 'labels'.</p> <p>Print the full metadata: <pre><code>pprint.pprint(dict(dataset.attrs))\n</code></pre></p> <p>Get multiscales metadata: <pre><code>meta = dict(dataset.attrs['multiscales'][0])\n</code></pre></p> <p>Print the axis ordering and the units <pre><code>pprint.pprint(meta['axes'])\naxis_order = ''.join(item['name'] for item in meta['axes'])\nprint(f\"Axis order is {axis_order}\")\n</code></pre> Print the voxel scaling for each resolution level <pre><code>for idx, transform in enumerate(meta['datasets']):\n    print(f\"\\033[1mVoxel transform for the level {idx}:\\033[0m\")\n    pprint.pprint(transform)\n</code></pre> Get the top resolution array: <pre><code>zarr_array0 = dataset[0]\nprint(f\"Array type: {type(zarr_array0)}\")\nprint(f\"Shape of the top-level array: {zarr_array0.shape}\")\n</code></pre> Get a downscaled array: <pre><code>zarr_array1 = dataset[1]\nprint(f\"Array type: {type(zarr_array1)}\")\nprint(f\"Shape of the first-level downscaled array: {zarr_array1.shape}\")\n</code></pre> Summarize array-level metadata: <pre><code>zarr_array0.info\nzarr_array1.info\n</code></pre> Print chunk size for the top layer: <pre><code>print(f\"Chunk size: {zarr_array0.chunks}\")\n</code></pre></p> <p>Convert the zarr array to a numpy array: <pre><code>numpy_array0 = zarr_array0[:]\nprint(f\"Array type: {type(numpy_array0)}\")\n# or use numpy directly\nnumpy_array0 = np.array(zarr_array0)\nprint(f\"Array type: {type(numpy_array0)}\")\n</code></pre></p> <p>Open a remote OME-Zarr using <code>zarr.open_group</code> <pre><code>url = \"https://uk1s3.embassy.ebi.ac.uk/idr/zarr/v0.4/idr0062A/6001240.zarr\"\ndataset = zarr.open_group(url, mode = 'r')\nprint(f\"Type of the dataset: {type(dataset)}\")\n</code></pre></p> <p>Note that once the remote data is opened this way, it can be inspected the same way using the same methods described above.</p>"},{"location":"open_ome_zarr_ome-zarr-py/","title":"ome-zarr-py","text":"<p>Import the relevant tools:</p> <pre><code>import ome_zarr, zarr, pprint, os\nfrom ome_zarr import utils\nfrom ome_zarr.reader import Reader\nfrom ome_zarr.io import parse_url\n</code></pre> <p>Use the utils module to inspect, download or validate the remote data</p> <p>Inspect: <pre><code>list(utils.info(\"https://uk1s3.embassy.ebi.ac.uk/EuBI/anna_steyer0/20160112_C.elegans_std_fullhead.zarr\"))\n</code></pre></p> <p>Download: <pre><code>utils.download(input_path = \"https://uk1s3.embassy.ebi.ac.uk/idr/zarr/v0.4/idr0062A/6001240.zarr\",\n               output_dir = \"/path/to/local/zarr\") # eg: \"/home/oezdemir/image_data_formats/day1/ome_zarr\"\n</code></pre></p> <p>Validate: <pre><code>utils.view(input_path = \"/local/path/to/6001240.zarr\")\n</code></pre></p> <p>Read remote OME-Zarr: <pre><code># local_path = f\"{os.path.expanduser('~')}/image_data_course/data/zarr/6001240.zarr\"\nremote_path = f\"https://uk1s3.embassy.ebi.ac.uk/idr/zarr/v0.4/idr0062A/6001240.zarr\"\nreader = Reader(parse_url(remote_path))\n# Note here that 'parse_url' can parse both remote and local urls.\n</code></pre></p> <p>Note that ome-zarr-py uses the term 'node' for different zarr groups and reads them in a flat list. </p> <p>Print the node information per resolution level:</p> <pre><code>nodes = list(reader())\nfor idx, node in enumerate(nodes):\n    print(f\"The node at the level {idx} is {node}\")\n</code></pre> <p>Get the data and metadata of the top-level node:</p> <p><pre><code>dataset = nodes[0].data\nmeta = nodes[0].metadata\n</code></pre> Check the 'data' instance to examine the array shape and the chunks for each resolution layer:</p> <pre><code>for idx, array in enumerate(dataset):\n    print(f\"The array {idx} is a {type(array)} and has shape {array.shape} and has chunks with shape {array.chunksize}\")\n</code></pre> <p>Print the axis types and units of the arrays using the metadata instance <pre><code>print(f\"Axis properties of the dataset:\")\npprint.pprint(meta['axes'])\n</code></pre> Print the voxel sizes per resolution level (and any other voxel transforms that may exist) <pre><code>for idx, transforms in enumerate(meta['coordinateTransformations']):\n    print(f\"\\033[1mThe transform metadata for the level {idx}:\\033[0m\")\n    print(f\"{transforms}\")\n</code></pre></p>"},{"location":"open_overview/","title":"Overview","text":"<p>Open local (file system) and remote (S3 object store) OME-Zarr data using various tools</p>"},{"location":"open_overview/#preparation","title":"Preparation","text":"<p>Please download and extract the OME-Zarr dataset</p>"},{"location":"open_overview/#modules","title":"Modules","text":"<ul> <li>Mobie</li> <li>n5-ij</li> <li>n5-viewer</li> <li>zarr-python</li> <li>ome-zarr-py</li> <li>napari-ome-zarr</li> <li>S3 Visualization (BIA)</li> <li>ITK Viewer</li> <li>Mobie for s3</li> <li>Neuroglancer</li> <li>Vizarr</li> <li>Webknossos</li> </ul>"},{"location":"save_ome_zarr_fiji/","title":"n5-ij","text":"<ul> <li>First open an image on Fiji by dragging and dropping the czi image from your local path (eg., <code>~/image_data_course/data/czi/xyz__multiple_images.czi</code>) as shown below: </li> <li>A window titled Bioformats Import Options will open. Then click OK without changing any options.</li> <li>Another window titled Bioformats Series Options will open. This shows that the czi file contains two independent images (or \"series\" in bioformats terminology). Then select one of the images and click OK as shown below: </li> <li>Now open the n5-ij's saving tool via: </li> <li><code>[ File &gt; Save As &gt; HDF5/N5/Zarr/OME-NGFF ... ]</code> as shown below </li> <li>This will open a window with saving options (which define the properties of the output OME-Zarr) as shown below: </li> </ul>"},{"location":"save_ome_zarr_ome-zarr-py/","title":"ome-zarr-py","text":"<p>Import the relevant tools:</p> <pre><code>import zarr, os\nimport numcodecs\nfrom ome_zarr import writer, scale\nfrom ome_zarr.io import parse_url\nfrom skimage.data import astronaut\n</code></pre> <p>Create fake data:</p> <pre><code>data = astronaut().swapaxes(0, 2).swapaxes(1, 2)\n</code></pre> <p>Create a zarr store to write:</p> <p>For the sake of simplicity, here we demonstrate how to write to a local store. It is also possible to write to a remote location by simply specifying a remote  url as input to the <code>parse_url</code> function.</p> <pre><code># Specify the path where you want to write\n# output_path = f\"{os.path.expanduser('~')}/image_data_formats/day2/astronaut.zarr\"\noutput_path = \"/path/to/astronaut.zarr\"\n# Parse the url as a zarr store. Note that \"mode = 'w'\" enables writing to this store.\nstore = parse_url(output_path, mode = 'w').store \nroot = zarr.open_group(store)\n</code></pre> <p>Specify a scaler:</p> <p>In order to create an image pyramid, one has to instantiate a scaler.  This scaler requires the parameters: scale factor, number of resolution layers and downscaling method. <pre><code>scaler = scale.Scaler(downscale=2, # Downscaling factor for x and y axes\n                      max_layer=4, # Number of downscalings = 5\n                      method = 'nearest' # downscaling method\n                      )\n</code></pre></p> <p>Specify the axis identities and the corresponding units:</p> <p>This dictionary will impose the axis order and the units corresponding to  each axis.</p> <pre><code>axes = [\n    dict(name = 'c', type = 'channel'),\n    dict(name = 'y', type = 'space', unit = 'micrometer'),\n    dict(name = 'x', type = 'space', unit = 'micrometer'),\n]\n</code></pre> <p>Specify the voxel sizes for each resolution level:</p> <p>This is a list of list, where the length of the outer list must match  the number of resolution levels. The inner lists contain dictionaries  for different types of coordinate transforms. Each inner list must  contain a scaling transform, a dictionary that takes <code>scale</code> as key  and an iterable of voxel sizes as value.</p> <pre><code>coordinate_transforms = [\n    [{'scale': [1, 0.2, 0.2], 'type': 'scale'}],\n    [{'scale': [1, 0.4, 0.4], 'type': 'scale'}],\n    [{'scale': [1, 0.8, 0.8], 'type': 'scale'}],\n    [{'scale': [1, 1.6, 1.6], 'type': 'scale'}],\n    [{'scale': [1, 3.2, 3.2], 'type': 'scale'}]\n]\n</code></pre> <p>Specify zarr storage options</p> <p>The most important zarr storage options are the <code>chunks</code> and the <code>compression</code>  parameters. The <code>chunks</code> parameter is simply a tuple of integers corresponding  to each axis. The <code>compression</code> parameter requires compressor object from  the <code>Numcodecs</code> package, which is a dependency of <code>zarr-python</code>.</p> <pre><code>storage_options=dict(\n                    chunks=(1, 64, 64),  # Output chunk shape\n                    compression = numcodecs.Zlib(), # Compressor to be used, defaults to numcodecs.Blosc()\n                    overwrite = True # Overwrite the output path\n                )\n</code></pre> <p>Save the array:</p> <p>Here we use the <code>ome_zarr.writer.write_image</code> function to save the array.  This function takes the parameters specified above as input, downscales the  array accordingly and writes the resulting pyramid to the specified zarr group. </p> <pre><code>writer.write_image(image = data, # In this case, a numpy array\n                   group = root,\n                   axes = axes, # Dimensionality order\n                   scaler=scaler,\n                   coordinate_transformations = coordinate_transforms,\n                   storage_options = storage_options\n                   )\n</code></pre>"},{"location":"save_overview/","title":"Overview","text":"<p>Save data from memory to OME-Zarr using different tools.</p>"},{"location":"save_overview/#preparation","title":"Preparation","text":"<p>Please download xyz__multiple_images.czi to a convenient local directory. \\ For example: <code>~/image_data_course/data/czi/xyz__multiple_images.czi</code></p>"},{"location":"save_overview/#modules","title":"Modules","text":"<ul> <li>n5-ij</li> <li>ome-zarr-py</li> </ul>"},{"location":"update_rendering_metadata/","title":"Update rendering metadata","text":"<p>Import the necessary modules</p> <pre><code>import zarr, os\nfrom ome_zarr.io import parse_url, utils\nimport matplotlib.colors as mcolors\n</code></pre> <p>At this stage inspect the image using the OME-Zarr validator:</p> <pre><code># path = f\"{os.path.expanduser('~')}/image_data_formats/day2/astronaut.zarr\"\npath = \"/path/to/astronaut.zarr\"\nutils.view(path) \n</code></pre> <p>Define a utility function to get the hex color code by simple color names</p> <pre><code>def get_color_code(color_name):\n    try:\n        color_code = mcolors.CSS4_COLORS[color_name.lower()]\n        return color_code\n    except KeyError:\n        return f\"Color '{color_name}' not found.\"\n</code></pre> <p>Now add rendering metadata</p> <pre><code>store = parse_url(path, mode = 'w').store # Create a zarr store to save the data. Note that this can also be an s3 object store.\nroot = zarr.open_group(store=store)\nroot.attrs[\"omero\"] = {\n    \"channels\": [\n        {\n            \"color\": get_color_code('cyan'),\n            \"window\": {\"start\": 0, \"end\": 255, \"min\": 0, \"max\": 255},\n            \"label\": \"ch0\",\n            \"active\": True,\n        },\n        {\n            \"color\": get_color_code('magenta'),\n            \"window\": {\"start\": 0, \"end\": 255, \"min\": 0, \"max\": 255},\n            \"label\": \"ch1\",\n            \"active\": True,\n        },\n        {\n            \"color\": get_color_code('yellow'),\n            \"window\": {\"start\": 0, \"end\": 255, \"min\": 0, \"max\": 255},\n            \"label\": \"ch2\",\n            \"active\": True,\n        },\n    ]\n}\n</code></pre> <p>It is important to know here that not all OME-Zarr readers recognize each of these settings. \\ Apply the validator again to the data to see the changes: <pre><code>path = \"/path/to/astronaut.zarr\"\nutils.view(path) \n</code></pre> As the data looks valid, now visualize using different viewers to see if the rendering is working.</p>"},{"location":"validate_ome_zarr_ome-zarr-validator/","title":"OME-Zarr Validator","text":"<p>Open the OME-Zarr validator with local data using ome-zarr-py from the command line:</p> <pre><code>ome_zarr view /path/to/local/omezarr # eg: ~/image_data_course/data/zarr/6001240.zarr\n</code></pre> <p>The validator will open in a web browser and demonstrate various metadata fields of the OME-Zarr dataset.</p> <ul> <li>Find out the metadata fields such as axes, units and scales.</li> <li>Check the array and chunk shapes and bytes per resolution level.</li> <li>Visualize a single chunk.</li> </ul> <p>Now do the same but with remote data:</p> <p>Enter the following into your browser: <code>https://ome.github.io/ome-ngff-validator/?source=</code></p> <p>Then paste the dataset url after the 'equal' sign, constructing the following link: </p> <p>https://ome.github.io/ome-ngff-validator/?source=https://uk1s3.embassy.ebi.ac.uk/idr/zarr/v0.4/idr0062A/6001240.zarr </p> <p>Note that with the remote url it is possible to copy the link from your browser and share it with  your colleagues.</p>"}]}